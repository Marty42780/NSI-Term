BACCALAURÃ‰AT  

SESSION 2023 
__________________ 

Ã‰preuve de lâ€™enseignement de spÃ©cialitÃ© 

NUMÃ‰RIQUE et SCIENCES 
INFORMATIQUES 

Partie pratique 

Classe Terminale de la voie gÃ©nÃ©rale 
_________________ 

Sujet nÂ°22 
__________________ 

DURÃ‰E DE Lâ€™Ã‰PREUVE : 1 heure 

Le sujet comporte 4 pages numÃ©rotÃ©es de 1 / 4 Ã  4 / 4 
DÃ¨s que le sujet vous est remis, assurez-vous quâ€™il est complet. 

Le candidat doit traiter les 2 exercices. 

 1 / 4 

 
 
 
 
 
 
 
 
 
 
EXERCICE 1 (4 points) 

On rappelle que : 

le nombre ð‘Žð‘› est le nombre  ð‘Ž Ã— ð‘Ž Ã— â€¦ Ã— ð‘Ž, oÃ¹ le facteur ð‘Ž apparaÃ®t ð‘› fois,   

ï‚· 
ï‚·  en  langage  Python,  lâ€™instruction  t[-1]  permet  dâ€™accÃ©der  au  dernier  Ã©lÃ©ment  du 

tableau t. 

Dans cet exercice, lâ€™opÃ©rateur ** et la fonction pow ne sont pas autorisÃ©s.  

Programmer en langage Python une fonction liste_puissances qui prend en argument 
un nombre entier a, un entier strictement positif n et qui renvoie la liste de ses puissances 
[a1, a2, ... , an ]. 

Programmer  Ã©galement  une  fonction  liste_puisssances_borne  qui  prend  en 
argument un nombre entier a supÃ©rieur ou Ã©gal Ã  2 et un entier borne, et qui renvoie la 
liste de ses puissances, Ã  lâ€™exclusion de a0, strictement infÃ©rieures Ã  borne. 

Exemples : 
>>> liste_puissances(3, 5) 
[3, 9, 27, 81, 243] 
>>> liste_puissances(-2, 4) 
[-2, 4, -8, 16] 
>>> liste_puissances_borne(2, 16) 
[2, 4, 8] 
>>> liste_puissances_borne(2, 17) 
[2, 4, 8, 16] 
>>> liste_puissances_borne(5, 5) 
[] 

 2 / 4 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
EXERCICE 2 (4 points) 

On affecte Ã  chaque lettre de lâ€™alphabet un code selon les tableaux ci-dessous : 

A  B  C  D  E  F  G  H 

I 

J  K  L  M 

1  2  3  4  5  6  7  8  9  10  11  12  13 

N  O  P  Q  R  S  T  U  V  W  X  Y  Z 

14  15  16  17  18  19  20  21  22  23  24  25  26 

Pour un mot donnÃ©, on dÃ©termine dâ€™une part son code alphabÃ©tique concatÃ©nÃ©, obtenu 
par la juxtaposition des codes de chacun de ses caractÃ¨res, et dâ€™autre part, son code 
additionnÃ©, qui est la somme des codes de chacun de ses caractÃ¨res.  
Par ailleurs, on dit que ce mot est Â« parfait Â» si le code additionnÃ© divise le code 
concatÃ©nÃ©. 

Exemples : 

-  Pour le mot "PAUL", le code concatÃ©nÃ© est la chaÃ®ne 1612112, soit lâ€™entier 

1612112. 
Son code additionnÃ© est lâ€™entier 50 car 16 + 1 + 21 + 12 = 50. 
50 ne divise pas lâ€™entier 1612112 ; par consÃ©quent, le mot "PAUL" nâ€™est pas 
parfait. 

- 
-  Pour le mot "ALAIN", le code concatÃ©nÃ© est la chaÃ®ne 1121914, soit lâ€™entier 

1121914. 
Le code additionnÃ© est lâ€™entier 37 car 1 + 12 + 1 + 9 + 14 = 37. 
37 divise lâ€™entier 1121914 ; par consÃ©quent, le mot "ALAIN" est parfait. 

ComplÃ©ter la fonction est_parfait fournie Ã  la page suivante qui prend comme 
argument une chaÃ®ne de caractÃ¨res mot (en lettres majuscules) et qui renvoie le code 
alphabÃ©tique concatÃ©nÃ©, le code additionnÃ© de mot, ainsi quâ€™un boolÃ©en qui indique si 
mot est parfait ou pas. 

 3 / 4 

 
 
 
 
 
 
 
 
 
 
 
 
 
dico = {"A": 1, "B": 2, "C": 3, "D": 4, "E": 5, "F": 6, 
        "G": 7, "H": 8, "I": 9, "J": 10, "K": 11, "L": 12, 
        "M": 13, "N": 14, "O": 15, "P": 16, "Q": 17, 
        "R": 18, "S": 19, "T": 20, "U": 21, "V": 22, 
        "W": 23, "X": 24, "Y": 25, "Z": 26} 

def est_parfait(mot) : 
    # mot est une chaÃ®ne de caractÃ¨res (en lettres majuscules) 
    code_concatene = "" 
    code_additionne = ... 
    for c in mot: 
        code_concatene = code_concatene + ... 
        code_additionne = ... 
    code_concatene = int(code_concatene) 
    if ... : 
        mot_est_parfait = True 
    else : 
        mot_est_parfait = False 
    return code_additionne, code_concatene, mot_est_parfait 

Exemples : 

>>> est_parfait("PAUL") 
(50, 1612112, False) 
>>> est_parfait("ALAIN") 
(37, 1121914, True) 

 4 / 4 

 
 
 
 
 
